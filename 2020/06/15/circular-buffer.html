<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" href="data:;base64,iVBORw0KGgo="><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Building Pipelines with Circular Buffers, not Queues | silicon_sprawl_</title>
<meta name="generator" content="Jekyll v4.0.1" />
<meta property="og:title" content="Building Pipelines with Circular Buffers, not Queues" />
<meta name="author" content="Eli Lindsey" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Structuring programs as pipelines is a nice way to separate business logic and introduce parallelism - if you do it right it gets you both clarity and performance." />
<meta property="og:description" content="Structuring programs as pipelines is a nice way to separate business logic and introduce parallelism - if you do it right it gets you both clarity and performance." />
<link rel="canonical" href="https://siliconsprawl.com/2020/06/15/circular-buffer.html" />
<meta property="og:url" content="https://siliconsprawl.com/2020/06/15/circular-buffer.html" />
<meta property="og:site_name" content="silicon_sprawl_" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-06-15T00:00:00+00:00" />
<script type="application/ld+json">
{"datePublished":"2020-06-15T00:00:00+00:00","author":{"@type":"Person","name":"Eli Lindsey"},"description":"Structuring programs as pipelines is a nice way to separate business logic and introduce parallelism - if you do it right it gets you both clarity and performance.","url":"https://siliconsprawl.com/2020/06/15/circular-buffer.html","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://siliconsprawl.com/2020/06/15/circular-buffer.html"},"headline":"Building Pipelines with Circular Buffers, not Queues","dateModified":"2020-06-15T00:00:00+00:00","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://siliconsprawl.com/feed.xml" title="silicon_sprawl_" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">silicon_sprawl_</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about.html">about</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Building Pipelines with Circular Buffers, not Queues</h1>
    <p class="post-meta"></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>Structuring programs as pipelines is a nice way to separate business logic and
introduce parallelism - if you do it right it gets you both clarity and
performance.</p>

<p>Typically this is done by tying threads together with some form of concurrent
queue, such as a channel in Golang, ConcurrentLinkedQueue in Java, or
concurrent_queue in C++ (Intel TBB or Microsoft PPL).</p>

<p>Using a simple integer pipeline as an example, we’ll have an initial phase
writing random integers, one phase that multiplies its input by two, one phase
that increments its input, and a final phase that prints the result.</p>

<p>With queues, it would look something like this:</p>

<p><img src="/assets/images/linear_pipeline.png" alt="linear pipeline diagram" /></p>

<p>But the overhead of multiple queues can be quite high and variable, so is often
unacceptable in low-latency programs. An alternative is to use a single
circular buffer and have each thread hold a cursor into it. This pattern has
significantly better behavior on current hardware and requires minimal
synchronization. It’s variously known as event sourcing, the LMAX Disruptor, or
“that giant circular buffer pattern.”</p>

<p>A shared circular buffer for our example would instead look like this:</p>

<p><img src="/assets/images/circular_pipeline.png" alt="circular pipeline diagram" /></p>

<p>One way to think about this is that we’re moving the executor to the data instead
of the data to the executor.</p>

<p>A few of the advantages:</p>
<ul>
  <li>Extremely good data locality. The prefetcher will pull data for the next item
into the cache before we need it and we’ll keep the CPU well-fed and happy.</li>
  <li>No data needs to be copied between phases, whereas the queue needs a copy
in/out of the queue. As the struct gets large the queue needs to start using
a pointer indirect, which again hurts locality and puts more pressure on the
gc. Since we don’t incur any expensive copies, the buffer can continue to store
large structs directly. If our struct is written appropriately we also won’t
need to do any expensive clean operation on struct reuse.</li>
  <li>Low contention. Each phase coordinates with a single atomic and one sync
operation can batch multiple items at once (ie. we only do one sync to take
ownership of all queued items for our phase), compared to a queue which
typically must synchronize on each item.</li>
  <li>Very few pointers for the gc to scan, possibly just the pointer to the
circular buffer and pointers between phases. With care we could code it to
generate zero garbage when in steady state.</li>
  <li>Performance is consistent. Where the queue has multiple buffers that need to
be sized, locks that may be contended, etc. it’s much easier in the circular
buffer to quantify the total amount of work in the system and the worst-case
performance under full load.</li>
</ul>

<p>A very barebones example:</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
	<span class="s">"math/rand"</span>
	<span class="s">"runtime"</span>
	<span class="s">"sync/atomic"</span>
<span class="p">)</span>

<span class="k">type</span> <span class="n">data</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">num</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">phase</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">_</span>        <span class="p">[</span><span class="m">7</span><span class="p">]</span><span class="kt">int64</span> <span class="c">// padding</span>
	<span class="n">cursor</span>   <span class="kt">int64</span>
	<span class="n">_</span>        <span class="p">[</span><span class="m">7</span><span class="p">]</span><span class="kt">int64</span> <span class="c">// padding</span>
	<span class="n">upstream</span> <span class="o">*</span><span class="n">phase</span>
<span class="p">}</span>

<span class="k">const</span> <span class="n">bufSize</span> <span class="o">=</span> <span class="m">64</span> <span class="c">// must be power of 2</span>
<span class="k">const</span> <span class="n">bufMask</span> <span class="kt">int64</span> <span class="o">=</span> <span class="n">bufSize</span> <span class="o">-</span> <span class="m">1</span>

<span class="k">var</span> <span class="n">circularBuf</span> <span class="p">[</span><span class="n">bufSize</span><span class="p">]</span><span class="n">data</span>

<span class="k">func</span> <span class="n">runPhase</span><span class="p">(</span><span class="n">p</span> <span class="o">*</span><span class="n">phase</span><span class="p">,</span> <span class="n">f</span> <span class="k">func</span><span class="p">(</span><span class="kt">int64</span><span class="p">))</span> <span class="p">{</span>
	<span class="n">curr</span> <span class="o">:=</span> <span class="kt">int64</span><span class="p">(</span><span class="m">0</span><span class="p">)</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="n">upstreamLimit</span> <span class="o">:=</span> <span class="n">atomic</span><span class="o">.</span><span class="n">LoadInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">.</span><span class="n">upstream</span><span class="o">.</span><span class="n">cursor</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">curr</span> <span class="o">!=</span> <span class="n">upstreamLimit</span> <span class="p">{</span>
			<span class="n">f</span><span class="p">(</span><span class="n">curr</span><span class="o">&amp;</span><span class="n">bufMask</span><span class="p">)</span>
			<span class="n">curr</span><span class="o">++</span>
		<span class="p">}</span>
		<span class="n">atomic</span><span class="o">.</span><span class="n">StoreInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">.</span><span class="n">cursor</span><span class="p">,</span> <span class="n">curr</span><span class="p">)</span>
		<span class="n">runtime</span><span class="o">.</span><span class="n">Gosched</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">runWriter</span><span class="p">(</span><span class="n">p</span> <span class="o">*</span><span class="n">phase</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">r</span> <span class="o">:=</span> <span class="n">rand</span><span class="o">.</span><span class="n">New</span><span class="p">(</span><span class="n">rand</span><span class="o">.</span><span class="n">NewSource</span><span class="p">(</span><span class="m">1</span><span class="p">))</span>
	<span class="n">curr</span> <span class="o">:=</span> <span class="kt">int64</span><span class="p">(</span><span class="m">0</span><span class="p">)</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="n">upstreamLimit</span> <span class="o">:=</span> <span class="n">atomic</span><span class="o">.</span><span class="n">LoadInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">.</span><span class="n">upstream</span><span class="o">.</span><span class="n">cursor</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">curr</span> <span class="o">==</span> <span class="n">upstreamLimit</span> <span class="p">{</span>
			<span class="c">// empty buffer</span>
			<span class="n">upstreamLimit</span> <span class="o">=</span> <span class="n">curr</span> <span class="o">+</span> <span class="n">bufSize</span> <span class="o">-</span> <span class="m">1</span>
		<span class="p">}</span>
		<span class="k">for</span> <span class="n">curr</span><span class="o">&amp;</span><span class="n">bufMask</span> <span class="o">!=</span> <span class="n">upstreamLimit</span><span class="o">&amp;</span><span class="n">bufMask</span> <span class="p">{</span>
			<span class="n">circularBuf</span><span class="p">[</span><span class="n">curr</span><span class="o">&amp;</span><span class="n">bufMask</span><span class="p">]</span><span class="o">.</span><span class="n">num</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">Intn</span><span class="p">(</span><span class="m">100</span><span class="p">)</span>
			<span class="n">curr</span><span class="o">++</span>
		<span class="p">}</span>
		<span class="n">atomic</span><span class="o">.</span><span class="n">StoreInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">.</span><span class="n">cursor</span><span class="p">,</span> <span class="n">curr</span><span class="p">)</span>
		<span class="n">runtime</span><span class="o">.</span><span class="n">Gosched</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c">// writeRandInt -&gt; multTwo -&gt; addOne -&gt; printResult</span>
	<span class="k">var</span> <span class="n">printResult</span><span class="p">,</span> <span class="n">addOne</span><span class="p">,</span> <span class="n">multTwo</span><span class="p">,</span> <span class="n">writeRandInt</span> <span class="n">phase</span>
	<span class="n">writeRandInt</span><span class="o">.</span><span class="n">upstream</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">printResult</span>
	<span class="n">printResult</span><span class="o">.</span><span class="n">upstream</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">addOne</span>
	<span class="n">addOne</span><span class="o">.</span><span class="n">upstream</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">multTwo</span>
	<span class="n">multTwo</span><span class="o">.</span><span class="n">upstream</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">writeRandInt</span>

	<span class="k">go</span> <span class="n">runWriter</span><span class="p">(</span><span class="o">&amp;</span><span class="n">writeRandInt</span><span class="p">)</span>

	<span class="k">go</span> <span class="n">runPhase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">addOne</span><span class="p">,</span> <span class="k">func</span><span class="p">(</span><span class="n">i</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">circularBuf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">num</span><span class="o">++</span>
	<span class="p">})</span>

	<span class="k">go</span> <span class="n">runPhase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">multTwo</span><span class="p">,</span> <span class="k">func</span><span class="p">(</span><span class="n">i</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">circularBuf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">num</span> <span class="o">*=</span> <span class="m">2</span>
	<span class="p">})</span>

	<span class="k">go</span> <span class="n">runPhase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">printResult</span><span class="p">,</span> <span class="k">func</span><span class="p">(</span><span class="n">i</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">circularBuf</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
	<span class="p">})</span>

	<span class="k">select</span> <span class="p">{}</span> <span class="c">// block forever</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This code is meant to show off the core concept in the smallest amount of code
possible. Fully building this out you would hide the cursor logic behind a nice
API and the final business logic would look very similar to a queue-based
implementation looping on a consume function.</p>

<p>A few specific notes about the implementation:</p>
<ol>
  <li>The cursors are not truncated to the size of the buffer each time they’re
incremented, instead they count towards integer max and wrap. This makes it
easy to disambiguate completely empty buffers from completely full buffers.</li>
  <li>The example has no backoff or wait strategy. Busy spin is what you’d want
for a high-load, low-latency system, but something that trades a small
amount of performance to let the CPU idle is preferable in other cases. Ideally
this would be implemented with direct calls to gopark/goready, but those aren’t
exposed externally by the runtime. A condvar can be used instead.</li>
  <li>The example also has no batching strategy except “grab everything
available”. This will lead to clumping, but fixing is trivial.</li>
  <li>On x86_64, atomic loads are compiled to <code class="highlighter-rouge">mov</code> and atomic stores are compiled
to <code class="highlighter-rouge">xchg</code>. arm64 compiles these to <code class="highlighter-rouge">ldar</code> and <code class="highlighter-rouge">stlr</code> respectively. This is
standard, but was my first time looking at the asm for atomics in golang, so I
was happy to see solid codegen.</li>
  <li>The conditional for the empty queue case in the writer is unfortunate.
Ideally we would write that conditional as straightline code, eg.
    <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">upstream</span> <span class="o">=</span> <span class="n">atomic</span><span class="o">.</span><span class="n">LoadInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">.</span><span class="n">upstream</span><span class="o">.</span><span class="n">cursor</span><span class="p">)</span>
<span class="n">empty</span> <span class="o">=</span> <span class="n">curr</span><span class="o">^</span><span class="n">upstream</span> <span class="o">==</span> <span class="m">0</span>
<span class="n">upstreamLimit</span> <span class="o">=</span> <span class="p">(</span><span class="n">upstream</span> <span class="o">*</span> <span class="o">!</span><span class="n">empty</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="n">curr</span> <span class="o">+</span> <span class="n">bufSize</span> <span class="o">-</span> <span class="m">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">empty</span><span class="p">)</span>
</code></pre></div>    </div>
    <p>This would generate a <code class="highlighter-rouge">cmp</code> but no <code class="highlighter-rouge">jmp</code>. Unfortunately I know of no way to
express this in go, and the optimizer doesn’t do it for us. It is a common pattern
in C and other systems programming languages.
Since we know the numbers are positive but we’re saving them in 2s complement,
in this case we do have a path to doing this with computation, but it’s
silly and mostly academic.</p>
    <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">upstream</span> <span class="o">:=</span> <span class="n">atomic</span><span class="o">.</span><span class="n">LoadInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">.</span><span class="n">upstream</span><span class="o">.</span><span class="n">cursor</span><span class="p">)</span>
<span class="n">notEmpty</span> <span class="o">:=</span> <span class="n">curr</span> <span class="o">^</span> <span class="n">upstream</span>
<span class="n">upmult</span> <span class="o">:=</span> <span class="p">(</span><span class="n">notEmpty</span> <span class="o">&gt;&gt;</span> <span class="m">63</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="o">-</span><span class="n">notEmpty</span> <span class="o">&gt;&gt;</span> <span class="m">63</span><span class="p">)</span>                                                                                                                                                  
<span class="n">upstreamLimit</span> <span class="o">:=</span> <span class="p">(</span><span class="n">upstream</span> <span class="o">*</span> <span class="n">upmult</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="n">curr</span> <span class="o">+</span> <span class="n">bufSize</span> <span class="o">-</span> <span class="m">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="o">^</span><span class="n">upmult</span> <span class="o">&amp;</span> <span class="m">1</span><span class="p">))</span> 
</code></pre></div>    </div>
    <p>Update: turns out there is a way to express this. At least as of go 1.19, this
generates the assembly I’m looking for - straightline code with a <code class="highlighter-rouge">cmp</code> but not <code class="highlighter-rouge">jmp</code>.</p>
    <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">upstream</span> <span class="o">:=</span> <span class="n">atomic</span><span class="o">.</span><span class="n">LoadInt64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">.</span><span class="n">upstream</span><span class="o">.</span><span class="n">cursor</span><span class="p">)</span>
<span class="n">empty</span> <span class="o">:=</span> <span class="kt">int64</span><span class="p">(</span><span class="m">0</span><span class="p">)</span>
<span class="k">if</span> <span class="n">curr</span><span class="o">^</span><span class="n">upstream</span> <span class="o">==</span> <span class="m">0</span> <span class="p">{</span>
 <span class="n">empty</span> <span class="o">=</span> <span class="m">1</span>
<span class="p">}</span>
<span class="n">upstreamLimit</span> <span class="o">:=</span> <span class="p">(</span><span class="n">upstream</span> <span class="o">*</span> <span class="p">(</span><span class="n">empty</span><span class="o">^</span><span class="m">1</span><span class="p">))</span> <span class="o">+</span> <span class="p">((</span><span class="n">curr</span> <span class="o">+</span> <span class="n">bufSize</span> <span class="o">-</span> <span class="m">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">empty</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
</ol>

<p>One last note: channels in go are deeply integrated with the runtime and do
things like make explicit gopark/goready calls, copy values from one
goroutine’s stack directly into another’s, etc. You could do a lot worse, and
should make sure they don’t fit your needs before rolling your own.</p>

  </div>

  <a class="u-url" href="/2020/06/15/circular-buffer.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1"><a class="u-email" href="mailto:eli@siliconsprawl.com">eli@siliconsprawl.com</a></div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/elindsey"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg></a></li><li><a href="https://www.linkedin.com/in/elilind"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#linkedin"></use></svg></a></li><li><a href="/feed.xml"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#rss"></use></svg></a></li></ul>
</div>
    </div>

  </div>

</footer>
</body>

</html>

