<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" href="data:;base64,iVBORw0KGgo="><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Fast Subnet Matching | silicon_sprawl_</title>
<meta name="generator" content="Jekyll v4.0.1" />
<meta property="og:title" content="Fast Subnet Matching" />
<meta name="author" content="Eli Lindsey" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Determining if a subnet contains a given IP is a fundamental operation in networking. Router dataplanes spend all of their time looking up prefix matches to make forwarding decisions, but even higher layers of application code need to perform this operation - for example, looking up a client IP address in a geographical database or checking a client IP against an abuse blocklist." />
<meta property="og:description" content="Determining if a subnet contains a given IP is a fundamental operation in networking. Router dataplanes spend all of their time looking up prefix matches to make forwarding decisions, but even higher layers of application code need to perform this operation - for example, looking up a client IP address in a geographical database or checking a client IP against an abuse blocklist." />
<link rel="canonical" href="https://siliconsprawl.com/2020/06/07/fast-subnet-matching.html" />
<meta property="og:url" content="https://siliconsprawl.com/2020/06/07/fast-subnet-matching.html" />
<meta property="og:site_name" content="silicon_sprawl_" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-06-07T00:00:00+00:00" />
<script type="application/ld+json">
{"datePublished":"2020-06-07T00:00:00+00:00","author":{"@type":"Person","name":"Eli Lindsey"},"description":"Determining if a subnet contains a given IP is a fundamental operation in networking. Router dataplanes spend all of their time looking up prefix matches to make forwarding decisions, but even higher layers of application code need to perform this operation - for example, looking up a client IP address in a geographical database or checking a client IP against an abuse blocklist.","url":"https://siliconsprawl.com/2020/06/07/fast-subnet-matching.html","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://siliconsprawl.com/2020/06/07/fast-subnet-matching.html"},"headline":"Fast Subnet Matching","dateModified":"2020-06-07T00:00:00+00:00","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://siliconsprawl.com/feed.xml" title="silicon_sprawl_" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">silicon_sprawl_</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about.html">about</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Fast Subnet Matching</h1>
    <p class="post-meta"></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>Determining if a subnet contains a given IP is a fundamental operation in
networking. Router dataplanes spend all of their time looking up prefix matches
to make forwarding decisions, but even higher layers of application code need
to perform this operation - for example, looking up a client IP address in a
geographical database or checking a client IP against an abuse blocklist.</p>

<p>Routers have extremely optimized implementations, but since these other uses
may be one-off codepaths in a higher-level language (eg. some random Go
microservice), they’re not written with the same level of care and
optimization.  Sometimes they’re written with no care or optimization at all
and quickly become bottlenecks.</p>

<p>Here’s a list of basic techniques and tradeoffs to reference next time you need
to implement this form of lookup; I hope it’s useful in determining a good
implementation for the level of optimization you need.</p>

<h3 id="multiple-subnets">Multiple Subnets</h3>

<p>If you have multiple subnets and want to determine which of them match a given
IP (eg. longest prefix match), you should be reaching for something in the trie
family. I won’t cover the fundamentals here, but do recommend <em>The Art of
Computer Programming, Vol.  3</em> for an overview.</p>

<p>Be extremely skeptical of any off-the-shelf radix libraries:</p>
<ol>
  <li>Many do not do prefix compression</li>
  <li>Many support N instead of two edges, which may lead to unnecessary memory overhead</li>
  <li>Many will operate on some form of string type to be as generic as possible, again contributing to memory overhead</li>
  <li>All be difficult to adapt to different stride lengths</li>
</ol>

<p>I would highly recommend writing your own implementation if performance is a
concern at all. Most common implementations are either too generic or are optimized
for exact instead of prefix match.</p>

<h4 id="unibit-to-multibit-to-compressed">unibit to multibit to compressed</h4>

<p>A radix 2 trie that does bit-by-bit comparison with compression for empty nodes
is a good starting point. To further speed it up, you’ll want to compare more
than one bit at a time - this is typically referred to as a multibit stride.</p>

<p>Multibit strides will get you significantly faster lookup time at the cost of
some memory - in order to align all comparisons on the stride size, you’ll need
to expand some prefixes.</p>

<p>As an example, let’s say you’re building a trie that contains three prefixes:</p>
<ul>
  <li>Prefix 1: 01*</li>
  <li>Prefix 2: 110*</li>
  <li>Prefix 3: 10*</li>
</ul>

<p>A unibit trie would look like this:
<img src="/assets/images/unibit.png" alt="unibit trie diagram" /></p>

<p>If instead we want to use a multibit trie with a stride of two bits, then
prefix 2 needs to be expanded into its two sub-prefixes, 1101* and 1100*. Our
multibit trie would look like this:</p>

<p><img src="/assets/images/multibit.png" alt="multibit trie diagram" /></p>

<p>Note how this trie has incresed our memory usage by duplicating prefix 2, but
has reduced our memory accesses and improved locality (there are far fewer
pointers chased in this diagram), thus trading memory usage for lookup
performance.</p>

<p>Most of the time a multibit trie is where you can stop. If you need to optimize
further, especially if you need to start reducing memory usage, then you’ll
want to explore the literature on compressed tries. The general idea with many
of these is to use a longer or adaptive stride, but find clever ways to remove
some of the redundancy it introduces. Starting points include LC-tries, Luleå
tries, and tree bitmaps.</p>

<h4 id="modified-traversals">Modified traversals</h4>

<p>There are some common, related problems that can be solved by small
modifications to the traversal algorithm:</p>
<ul>
  <li>If instead of finding the longest
prefix match you need to find all containing subnets, simply keep track of the
list of all matching nodes instead of the single most recent node as you
traverse and return the full set at the end.</li>
  <li>If you need to match a containing subnet on some criteria other than most
specific match, for example declaration order from a config file, express this
as a numerical priority and persist it alongside the node. As you traverse,
keep track of the most recently visited node and only replace it if the
currently visited is a higher priority.</li>
</ul>

<h4 id="sidenote-on-patricia-tries">Sidenote on PATRICIA tries</h4>

<p>PATRICIA tries are a radix 2 trie that saves a
count of bits skipped instead of the full substring when doing compression. You
don’t want this! They’re great for exact match lookup, like what you’d want in
a trie of filenames, but saving only the skip count causes prefix matches to
backtrack, resulting in significantly worse performance. It’s unfortunate that
they’re so often associated with networking; in some cases the name is misused
and people say PATRICIA when they simple mean radix 2.</p>

<h3 id="single-subnet">Single Subnet</h3>

<p>If you have a large number of IPs and want to check if a single subnet contains
them, spend a little time looking at your assembler output to choose a good
implementation. If available, you’re best off using 128-bit literals to support
IPv6. C, C++, Rust, and many systems languages will support this.
Unfortunately Go and Java do not, so you’ll have to piece it together with two
64-bit integers - slightly cumbersome, and slightly more overhead as we’ll see.</p>

<p>In IPv4, subnet contains checking is easy since everything fits in a word,
roughly:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// checking if 1.2.3.0/8 contains 1.2.3.4</span>
<span class="kt">uint32_t</span> <span class="n">prefix</span> <span class="o">=</span> <span class="mh">0x01020300</span><span class="p">;</span> <span class="c1">// prefix address, packed big endian</span>
<span class="kt">uint32_t</span> <span class="n">client</span> <span class="o">=</span> <span class="mh">0x01020304</span><span class="p">;</span> <span class="c1">// client address, packed big endian</span>
<span class="kt">uint8_t</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span> <span class="c1">// netmask, range 0-32</span>
<span class="kt">uint32_t</span> <span class="n">bitmask</span> <span class="o">=</span> <span class="mh">0xFFFFFFFF</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">32</span> <span class="o">-</span> <span class="n">mask</span><span class="p">);</span> <span class="c1">// invert the mask to get a count of number of zeros</span>
<span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">prefix</span> <span class="o">&amp;</span> <span class="n">bitmask</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">client</span> <span class="o">&amp;</span> <span class="n">bitmask</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
    <span class="c1">// subnet contains client</span>
<span class="p">}</span>
</code></pre></div></div>

<p>IPv6 is when things get interesting. 128-bit long IPv6 addresses means juggling
two machine words. In computing the bitmask we need a mask for the upper and
the lower portion of the address.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint64_t</span> <span class="n">upper_prefix</span><span class="p">,</span> <span class="n">lower_prefix</span><span class="p">,</span> <span class="n">upper_client</span><span class="p">,</span> <span class="n">lower_client</span> <span class="o">=</span> <span class="p">;</span> <span class="c1">// assume these are initialized</span>
<span class="kt">uint8_t</span> <span class="n">mask</span> <span class="o">=</span> <span class="p">;</span><span class="c1">// netmask, range 0-128</span>
<span class="kt">uint64_t</span> <span class="n">upper_bitmask</span> <span class="o">=</span> <span class="n">UINT64_MAX</span><span class="p">;</span>
<span class="kt">uint64_t</span> <span class="n">lower_bitmask</span> <span class="o">=</span> <span class="n">UINT64_MAX</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&lt;</span> <span class="mi">64</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">lower_bitmask</span> <span class="o">&lt;&lt;=</span> <span class="n">mask</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">upper_bitmask</span> <span class="o">=</span> <span class="n">lower_bitmask</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">64</span> <span class="o">-</span> <span class="n">mask</span><span class="p">);</span>
    <span class="n">lower</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">((</span><span class="n">upper_prefix</span> <span class="o">&amp;</span> <span class="n">upper_bitmask</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">upper_client</span> <span class="o">&amp;</span> <span class="n">upper_bitmask</span><span class="p">)</span> 
    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">lower_prefix</span> <span class="o">&amp;</span> <span class="n">lower_bitmask</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">lower_client</span> <span class="o">&amp;&amp;</span> <span class="n">lower_bitmask</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// subnet contains client</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Rewriting with gcc/clang’s int128 emulated type:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">__uint128</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">client</span> <span class="o">=</span> <span class="p">;</span> <span class="c1">// assume these are initialized</span>
<span class="kt">uint8_t</span> <span class="n">mask</span> <span class="o">=</span> <span class="p">;</span><span class="c1">// netmask, range 0-128</span>
<span class="n">__uint128</span> <span class="n">bitmask</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">__uint128_t</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">()</span> <span class="o">&lt;&lt;=</span> <span class="p">(</span><span class="mi">128</span> <span class="o">-</span> <span class="n">mask</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">prefix</span> <span class="o">&amp;</span> <span class="n">bitmask</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">client</span> <span class="o">&amp;</span> <span class="n">bitmask</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
    <span class="c1">// subnet contains client</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The emulated int128s are much easier to read and work with, but how does performance compare?</p>

<p>Here is the source code and <a href="https://godbolt.org/z/afNGvT">Godbolt link</a> for a
small test, isolating just the shift portion:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;cstdint&gt;
</span>
<span class="n">__int128</span> <span class="nf">shift128</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">shift</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">__int128</span> <span class="n">t</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">t</span> <span class="o">&lt;&lt;=</span> <span class="n">shift</span><span class="p">;</span> 
    <span class="k">return</span> <span class="n">t</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">Pair</span> <span class="p">{</span>
    <span class="kt">uint64_t</span> <span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">Pair</span> <span class="nf">shift64</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">shift</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uint64_t</span> <span class="n">upper</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">lower</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">shift</span> <span class="o">&lt;</span> <span class="mi">64</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">lower</span> <span class="o">&lt;&lt;=</span> <span class="n">shift</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">upper</span> <span class="o">=</span> <span class="n">lower</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">shift</span> <span class="o">-</span> <span class="mi">64</span><span class="p">);</span>
        <span class="n">lower</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">Pair</span><span class="p">{</span><span class="n">upper</span><span class="p">,</span> <span class="n">lower</span><span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And here is the compiler’s optimized x86 assembly with comments added:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>shift128(unsigned char):
        mov     ecx, edi ; load mask into ecx
        mov     rax, -1 ; initialize lower word
        xor     esi, esi ; zero this register for use in cmov
        mov     rdx, -1 ; initialize upper word
        sal     rax, cl ; shift lower word by mask
        and     ecx, 64 ; and our mask with 64
        cmovne  rdx, rax ; move lower word into upper
        cmovne  rax, rsi ; zero lower word
        ret
shift64(unsigned char):
        movzx   ecx, dil ; load mask into ecx
        cmp     dil, 63
        ja      .L4 ; jump if mask is &gt;= 64
        mov     rdx, -1 ; initialize lower word
        mov     rax, -1 ; initialize upper word
        sal     rdx, cl ; shift lower word by mask
        ret
.L4:
        sub     ecx, 64 ; find out how much we need to shift the upper word by
        mov     rax, -1 ; initialize upper word
        xor     edx, edx ; mask was &gt;64, so just zero the lower word
        sal     rax, cl ; shift upper word
        ret
</code></pre></div></div>

<p>There are a few interesting things to note:</p>
<ol>
  <li><code class="highlighter-rouge">sal</code> will automatically mask its shift operand to the appropriate range, so
while it’s undefined behavior in C to shift by more than the size of the
target, this is fine at the asm level</li>
  <li><code class="highlighter-rouge">and</code> with 64 is using knowledge of undefined behavior - our shift is only
well-defined within the range of 1-127, so we assume UB is impossible and
ignore the range outside.</li>
  <li><code class="highlighter-rouge">cmov</code> is used instead of a jump. On modern hardware this should be strictly
better, though is most noticeable when jumps are unpredictable. Our jumps
should be very predictable here.</li>
</ol>

<p>If we wanted, we could rewrite the int64 version in a way that would more
closely match the int128 assembly:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Pair</span> <span class="nf">shift64_v2</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">shift</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">uint64_t</span> <span class="n">upper</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">lower</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">lower</span> <span class="o">&lt;&lt;=</span> <span class="p">(</span><span class="n">shift</span> <span class="o">&amp;</span> <span class="mh">0x3F</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">shift</span> <span class="o">&gt;</span> <span class="mh">0x3F</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">upper</span> <span class="o">=</span> <span class="n">lower</span><span class="p">;</span>
        <span class="n">lower</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">Pair</span><span class="p">{</span><span class="n">upper</span><span class="p">,</span> <span class="n">lower</span><span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>shift64_v2(unsigned char):
        mov     ecx, edi
        mov     rdx, -1
        mov     rax, -1
        sal     rdx, cl
        cmp     dil, 63
        jbe     .L4
        mov     rax, rdx
        xor     edx, edx
.L4:
        ret
</code></pre></div></div>

<p>Note how the assembly does not contain any explicit <code class="highlighter-rouge">and</code> with 0x3F, we’ve
merely communicated to the compiler that we want the <code class="highlighter-rouge">sal</code> instruction’s
default mask behvior. Our <code class="highlighter-rouge">cmov</code> has also been converted to <code class="highlighter-rouge">jmp</code>.</p>

<p>Previously I’d hoped that I could use the 128-bit SSE registers and mm
intrinsics to operate on IPv6 addresses natively. However, operations to use
SSE registers as a single 128-bit value (as opposed to 2 64-bit values, 4
32-bit values, etc.) are quite limited. In particular, <code class="highlighter-rouge">_mm_slli_si128</code> shifts
by bytes instead of bits so won’t work for our use case (though SIMD
instructions would be useful for performing matches against multiple client IPs
at once).</p>

  </div>

  <a class="u-url" href="/2020/06/07/fast-subnet-matching.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1"><a class="u-email" href="mailto:eli@siliconsprawl.com">eli@siliconsprawl.com</a></div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/elindsey"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg></a></li><li><a href="https://www.linkedin.com/in/elilind"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#linkedin"></use></svg></a></li><li><a href="/feed.xml"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#rss"></use></svg></a></li></ul>
</div>
    </div>

  </div>

</footer>
</body>

</html>

