<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=icon href=data:,%89PNG%0D%0A%1A%0A><link rel=stylesheet href=/style.css><link rel=canonical href=https://siliconsprawl.com/posts/simd-ray-tracer/><title>Rust Ray Tracer, an Update (and SIMD)</title><meta name=author content="Eli Lindsey"><meta property="og:title" content="Rust Ray Tracer, an Update (and SIMD)"><meta property="og:description" content="About a month ago I ported my C99 ray tracer side project to Rust. The initial port went smoothly, and I&rsquo;ve now been plugging away adding features and repeatedly rewriting it in my spare hours. In parallel I&rsquo;m getting up to speed on a large, production Rust codebase at work. The contrast between the two has been interesting - I have almost entirely positive things to say about Rust for large, multi-threaded codebases, but it hasn&rsquo;t been as good of a fit for the ray tracer."><meta property="og:type" content="article"><meta property="og:url" content="https://siliconsprawl.com/posts/simd-ray-tracer/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-11-06T00:00:00+00:00"><meta property="article:modified_time" content="2020-11-06T00:00:00+00:00"></head><body><header role=banner class=site-header><div class=wrapper><a class=site-title href=https://siliconsprawl.com>silicon_sprawl_</a><nav class=site-nav><a class=page-link href=/about/ title=about>about</a></nav></div></header><main class=page-content><div class=wrapper><article><header class=post-header><h1 class="post-title p-name">Rust Ray Tracer, an Update (and SIMD)</h1></header><div class="post-content e-content"><p>About <a href=/2020/09/27/rust-ray-tracer.html>a month ago</a> I ported my C99 ray
tracer side project to Rust. The initial port went smoothly, and I&rsquo;ve now
been plugging away adding features and repeatedly rewriting it in my spare hours.
In parallel I&rsquo;m getting up to speed on a large, production Rust codebase at work.
The contrast between the two has been interesting - I have almost
entirely positive things to say about Rust for large, multi-threaded
codebases, but it hasn&rsquo;t been as good of a fit for the ray tracer.</p><p>It&rsquo;s not a <em>bad</em> fit, but C/C++ are almost perfectly suited for this domain. Many of
Rust&rsquo;s flagship features aren&rsquo;t applicable and/or get in the way - for
example, the borrow checker doesn&rsquo;t get me anything that ASAN wouldn&rsquo;t in
this specific use case, though does cause some additional headaches.</p><p>What follows are a few of the quirks I&rsquo;ve come across.</p><h2 id=overhead-of-thread-locals>Overhead of Thread Locals</h2><p>There was a <a href=https://matklad.github.io/2020/10/03/fast-thread-locals-in-rust.html>recent blog post</a>
about this, so I won&rsquo;t get into it very much.</p><p>Suffice to say that thread locals in C already have more overhead than I&rsquo;d
like since they introduce a level of indirection on use, and the additional
overhead of lazy initialization is significant. I found myself golfing down
TLS access whereever possible (&ldquo;I&rsquo;ll persist this in TLS, but copy it out
to/write it back from the stack&rdquo;).</p><p>Nightly has <a href=https://github.com/rust-lang/rust/issues/29594>an attribute</a>
that can be used to get a barebones thread local, but I&rsquo;m trying to avoid
nightly if possible.</p><p>Ultimately I got rid of TLS use entirely, but it meant moving away from rayon.</p><h2 id=difficulty-of-expressing-mutable-array-access>Difficulty of expressing mutable array access</h2><p>At its core a ray tracer is a giant array of pixels. You read a
pixel, do some math, and write it back. This is trivial to parallelize by
assigning disjoint sets of indices to threads, but often ends up being a
little difficult to express in Rust. In particular, non-contiguous,
cross-thread write access seems impossible to model safely without doing a
copy pass over the array (ie. using split to slice it up into contiguous owned
chunks, then later copying/rearranging it into the required non-contiguous order).</p><p>This makes it a bit annoying to write a tile-based instead of row or pixel-based tracer.</p><h2 id=undefined-undefined-behavior>&lsquo;Undefined&rsquo; Undefined Behavior</h2><p>I&rsquo;ve found it hard to tell what is and isn&rsquo;t undefined behavior in Rust.
There&rsquo;s the <a href=https://doc.rust-lang.org/nomicon/>Rustonomicon</a>, but it&rsquo;s
sparse in places. In particular, I don&rsquo;t have a good feel for what transmutes
are and aren&rsquo;t safe. One route is to outsource all that concern to something
like <a href=https://crates.io/crates/bytemuck>bytemuck</a> and let
<a href=https://github.com/Lokathor>Lokathor</a> worry about it. But for this project
I&rsquo;ve been avoiding taking deps unless completely necessary, because&mldr;</p><h2 id=compilation-speed>Compilation speed</h2><p>&mldr;compilation speed is atrocious. My work builds take an ungodly amount of
time. I&rsquo;ve been very picky about dependent libraries to keep this ray
tracer&rsquo;s incremental build as low as possible.</p><h2 id=operator-overloading-and-numeric-traits>Operator overloading and numeric traits</h2><p>I used to dismiss operator overloading as a frivolous feature, but it&rsquo;s been
valuable for floating point and SIMD math. Compilers
generally aren&rsquo;t going to do as much algebraic rearranging/simplification
with those types, and it&rsquo;s much easier to notice and tease out shared
operations when operator overloading is used. That said, I would love to
be able to do arbitrary overrides for <code>&lt;</code>, <code>></code>, etc. because SIMD types
aren&rsquo;t a good fit for <code>std::cmp::PartialOrd</code>.</p><p>As much as I like traits and bounded generics, they&rsquo;ve been
painful when it comes to numeric types. A core type in my ray tracer is <code>Vec3</code>,
a struct of three <code>f32s</code>. I wanted to make it generic across a SIMD type to let
me work with 8 <code>Vec3s</code> at once, so instead of three <code>f32s</code> it would have three
8-wide <code>f32s</code> in struct-of-arrays form. This proved to be&mldr; not worth the
hassle. In C++ I could write the <code>Vec3</code> logic (dot product, cross product,
etc.) as usual, parameterize it by <code>f32</code> or <code>f32x8</code>, then go implement whatever
mathematical overloads were missing. In Rust I need a set of unified traits
between <code>f32</code> and <code>f32x8</code>. Either I need to define that unified trait myself,
which is a lot of boilerplate, or I can use something like <a href=https://crates.io/crates/num>the num
crate</a>, which would require implementing more
functionality than I actually use (and some of which isn&rsquo;t applicable to
SIMD).</p><p>Ultmately I didn&rsquo;t bother.</p><h2 id=rayon>Rayon</h2><p>Rayon is a fantastic library. It was much nicer to work with than OpenMP,
and <code>iter_bridge</code> makes it dead simple to plug in anywhere.</p><p>Ultimately I ditched it for two reasons:</p><ol><li>I couldn&rsquo;t find a way to directly control thread init, which meant I
couldn&rsquo;t replace my thread locals with stack variables. You can mostly get around this
by using the <code>_init</code> methods that take a closure, reading a thread local onto
the stack then writing it back when the thread finishes its jobs.</li><li>It does far more than I need, which came out in a number of small ways -
like making profiler output harder to read because of a large number of
nested joins.</li></ol><p>I ultimately switched to using crossbeam directly, spinning up my own thread
pool reading off of a simple mpmc queue. Interestingly this is as fast as
rayon with <code>iter_bridge</code>, but is measurably slower than rayon&rsquo;s custom
parallel iterators for <code>Vecs</code>. I&rsquo;m still looking at why exactly that is, but it
seems like rayon is doing a better job of load-balancing work. Ray tracers
have a large number of pixels that can be processed in parallel, but each
pixel has a variable amount of work, so you need to strike a balance between
making batches too big (then one thread finishes early and you don&rsquo;t fully
utilize the machine) and too small (more thread contention to grab jobs). I
need to add logging to rayon&rsquo;s join splitting, but my hunch is that it&rsquo;s
doing a better job of keeping the batch size as high as possible without
causing cores to go idle.</p><p>Update: See <a href=/2020/11/09/rust-emit-asm.html>this post</a> for more
investigation of the performance regression.</p><h2 id=simd>SIMD</h2><p>There are a few different places where SIMD is applicable in a ray tracer:</p><ul><li>Do <code>Vec3</code> operations in SIMD. This is a common initial idea, <a href=https://fgiesen.wordpress.com/2016/04/03/sse-mind-the-gap/>but it&rsquo;s not
particularly
fruitful</a>.</li><li>Process multiple pixels or multiple rays for the same
pixel in SIMD. This is very useful, though requires writing SIMD versions
of some libm functions (notably trig functions). It&rsquo;s also where you start
hitting ray coherency problems - if you shoot 8 rays in a batch at roughly
the same area of the scene, it&rsquo;s likely that they&rsquo;ll behave similarly. But as
soon as they hit an object and bounce they all head in different directions,
and pretty quickly you end up with dead lanes. Unless your scene is very
simple that&rsquo;s still going to be a net win. Then coherency issues can come up
<em>again</em> once you&rsquo;ve calculated your hits and need to process materials - a
ray of light hitting a lake leads to very different math from a ray of light
hitting a tree. A good strategy for dealing with such things is to switch
from doing a depth-first traversal of the scene to breadth-first, letting you
accumulate enough state to batch likes with likes and pull, say, &lsquo;8 tree
hits&rsquo;, &lsquo;8 water hits&rsquo;, etc. from the work queue all at once. The tradeoff is
now you have a significant amount of additional memory use and possibly more
thread synchronization, so it&rsquo;s easy to accidentally make everything worse
and slower (I&rsquo;ve heard it&rsquo;s more effective on GPUs, but know less about
that). One very good paper on this style of optimized breadth-first CPU ray
tracing is <a href=https://www.embree.org/papers/2016-HPG-shading.pdf>this one</a>
from Intel.</li><li>Perform intersection checks for a single ray in SIMD. This isn&rsquo;t as big
of an improvement as the former, but given the effort it has great bang for your buck. Most of the work to add SIMD
was defining pass-through functions for intrinsics, with a few gnarlier ones
here and there (eg. hmin). The trickier optimization work came from going
back over the code and looking for any small places that I could simplify the
calculations - little things like removing a negation or redundant multiply,
switching to fma, etc. added up to substantial improvements.</li></ul><p>This was my first time using AVX2, and I didn&rsquo;t realize it&rsquo;s essentially
&ldquo;SSE but bigger.&rdquo; In particular I was surprised that you can&rsquo;t permute across
128-bit lanes.</p><p>Other surprises were that rsqrt with a refinement iteration
was slower than simply calling sqrt (though the Intel optimization manual did
warn me about this on Skylake - I have so much other math going on that it led
to port contention). And the cost of float conversions add up very quickly -
initially I was lazy and only implemented an 8-wide <code>f32</code> type, then would cast
in/out if I needed some integer type instead. Adding a proper <code>i32x8</code> got me a
few percentage points of runtime improvement.</p><p>Rust&rsquo;s current SIMD support is the absolute bare minimum. Intrinsics are exposed, all must be
used in unsafe, and if you dig you can find some docs on <code>repr(simd)</code>.
There&rsquo;s also a smattering of SIMD crates, some
<a href=https://crates.io/crates/wide>good</a>, some bad, some seemingly unmaintained.
There&rsquo;s nothing as complete or useful as <a href=https://github.com/vectorclass/version2>Agner Fog&rsquo;s
VCL</a>. There <em>is</em> however <a href=https://github.com/rust-lang/project-portable-simd>an active
working group</a> adding
portable SIMD abstractions to the core. That&rsquo;s very exciting, and looks like it&rsquo;s shaping up
nicely.</p><h2 id=debugging>Debugging</h2><p>Debugging ray tracers is surprisingly fun; you end up with a lot of &ldquo;how on earth did <em>that</em> happen&rdquo; moments. Here are a few of my recent head scratchers:</p><h3 id=reference-image>Reference Image</h3><p><img src=reference1.png alt></p><p>This is my current reference scene. Not too exciting - I need to invest some time in building out a more complex scene and possibly adding obj/triangle support. But the performance work tends to be more fun.</p><h3 id=blurred>Blurred</h3><p><img src=bad_blur1.png alt></p><p>I have no idea what happened here. I found this in my output folder over the course of doing the refactor from rayon to crossbeam, so I don&rsquo;t know exactly what broke - but I thought it was neat.</p><h3 id=ripples>Ripples</h3><p><img src=bad_fp1.png alt></p><p>This came from some bad floating point math - I think I messed up the intersection calculation in some way, but don&rsquo;t remember exactly how. I thought the ripple effect was kinda fun.</p><h3 id=fun-house-mirrors>Fun House Mirrors</h3><p><img src=bad_normalize1.png alt></p><p>&ldquo;Maybe I don&rsquo;t need to normalize my vectors here&mldr;&rdquo;</p><p><em>tries it</em></p><p>&ldquo;Nope, I definitely need to normalize there.&rdquo;</p><h3 id=inside-out>Inside Out</h3><p><img src=bad_sqrt1.png alt></p><p>This came from trying to use a fast inverse sqrt without a refinement step. A lot of my intersections were messed up, so rays ended up bouncing around <em>inside</em> objects and things got weird.</p></div></article></div></main><footer class="site-footer h-card"><div class=wrapper><div class=footer-col-wrapper><div class="footer-col footer-col-1"><a class=u-email href=mailto:eli@siliconsprawl.com>eli@siliconsprawl.com</a></div><div class="footer-col footer-col-2"><ul class=social-media-list><li><a href=https://github.com/elindsey><svg class="svg-icon"><use xlink:href="/social-icons.svg#github"/></svg></a></li><li><a href=https://www.linkedin.com/in/elilind><svg class="svg-icon"><use xlink:href="/social-icons.svg#linkedin"/></svg></a></li><li><a href=https://siliconsprawl.com/feed.xml><svg class="svg-icon"><use xlink:href="/social-icons.svg#rss"/></svg></a></li></ul></div></div></div></footer></body></html>